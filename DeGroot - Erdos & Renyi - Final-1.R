memory.limit(size = 8000000000000)                                                                                                                                                              # Allocates memory.
library("igraph")                                                                                                                                                                               # Loads "igraph" package.
library("DescTools")                                                                                                                                                                            # Loads "DescTools" package.
library("moments")                                                                                                                                                                              # Loads "moments" package.

networks.number <- 20                                                                                                                                                                          	# Number of networks that we are going to create and study.

vertices.number <- 30                                                                                                                                                                           # Number of vertices on each network.
vertices.names <- 1:vertices.number                                                                                                                                                             # Vertices are named from 1 to the number of vertices on each network.

prob <- seq(from = 0.01, to = 0.99, by = 0.01)                                                                                                                                                  # Vector of probability that an edge exists connecting two vertices in the networks that we are going to create and study.

for (p in 1:length(prob)){                                                                                                                                                                      # Loop for on the vector of probability that an edge exists connecting two vertices in the networks that we are going to create and study.
  
  probability <- prob[p]                                                                                                                                                                        # Stores the current edge probability.
  adjacency <- list()                                                                                                                                                                           # Creates a list of adjacency matrices, one to each network.
  
  ##############################################################################################################################################################################################
  ########################################################################     LISTS OF NETWORK STRUCTURE MEASURES     #########################################################################
  ##############################################################################################################################################################################################
  
  connected <- list()                                                                                                                                                                           # Creates a list where each entry tells if the corresponding network is connected (TRUE) or not (FALSE).
  components.number <- list()                                                                                                                                                                   # Creates a list where each entry stores the number of components on the corresponding network.
  components.size <- list()                                                                                                                                                                     # Creates a list where each entry stores the relative size of the components (fraction of vertices contained in them) on the corresponding network.
  components.largest <- list()                                                                                                                                                                  # Creates a list where each entry stores the relative size of the largest components (fraction of vertices contained in them) on the corresponding network.
  components.largest.number <- list()                                                                                                                                                           # Creates a list where each entry stores the number of largest components on the corresponding network.
  mean.distance <- list()                                                                                                                                                                       # Creates a list where each entry stores the mean distance between the vertices on the corresponding network.
  diameter <- list()                                                                                                                                                                            # Creates a list where each entry stores the diameter of the corresponding network.
  girth <- list()                                                                                                                                                                               # Creates a list where each entry stores the girth of the corresponding network.
  cliques3 <- list()                                                                                                                                                                            # Creates a list where each entry stores the number of cliques with at least 3 vertices on the corresponding network.
  cliques4 <- list()                                                                                                                                                                            # Creates a list where each entry stores the number of cliques with at least 4 vertices on the corresponding network.
  cliques.largest <- list()                                                                                                                                                                     # Creates a list where each entry stores the relative size of the largest cliques (fraction of vertices contained in them) on the corresponding network.
  cliques.largest.number <- list()                                                                                                                                                              # Creates a list where each entry stores the number of largest cliques on the corresponding network.
  maximal.cliques.number <- list()                                                                                                                                                              # Creates a list where each entry stores the number of maximal cliques on the corresponding network.
  
  ##############################################################################################################################################################################################
  ###########################################################################     LISTS OF CENTRALITY MEASURES     #############################################################################
  ##############################################################################################################################################################################################
  
  degree <- list()                                                                                                                                                                              # Creates a list where each entry stores the degree of the vertices on the corresponding network.
  #alpha.centrality <- list()                                                                                                                                                                   # Creates a list where each entry stores the alpha centrality of the vertices on the corresponding network.
  #power.centrality <- list()                                                                                                                                                                   # Creates a list where each entry stores the Bonacich power centrality scores of network position of the vertices on the corresponding network.
  authority.score <- list()                                                                                                                                                                     # Creates a list where each entry stores the Kleinberg's authority centrality scores of the vertices on the corresponding network.
  hub.score <- list()                                                                                                                                                                           # Creates a list where each entry stores the Kleinberg's hub centrality scores of the vertices on the corresponding network.
  eigen.centrality  <- list()                                                                                                                                                                   # Creates a list where each entry stores the eigenvector centrality scores of network position of the vertices on the corresponding network.
  triangle.centrality <- list()                                                                                                                                                                 # Creates a list where each entry stores the number of triangles each vertex is part of on the corresponding network.
  closeness.centrality <- list()                                                                                                                                                                # Creates a list where each entry stores the closeness centrality of the vertices on the corresponding network.
  burt <- list()                                                                                                                                                                                # Creates a list where each entry stores the Burt's constraint of the vertices on the corresponding network.
  longest.geodesic <- list()                                                                                                                                                                    # Creates a list where each entry stores each vertex's shortest path distance from the farthest other vertex on the corresponding network.
  betweenness <- list()                                                                                                                                                                         # Creates a list where each entry stores the betweenness centrality of the vertices on the corresponding network.
  degree.centrality.network <- list()                                                                                                                                                           # Creates a list where each entry stores the network-level degree centrality of the corresponding network.
  eigen.centrality.network <- list()                                                                                                                                                            # Creates a list where each entry stores the network-level eigenvector centrality of the corresponding network.
  closeness.centrality.network <- list()                                                                                                                                                        # Creates a list where each entry stores the network-level closeness centrality of the corresponding network.
  betweenness.centrality.network <- list()                                                                                                                                                      # Creates a list where each entry stores the network-level betweenness centrality of the corresponding network.
  
  ##############################################################################################################################################################################################
  ############################################################################     LISTS OF BELIEFS AND UPDATES     ############################################################################
  ##############################################################################################################################################################################################
  
  beliefs <- list()                                                                                                                                                                             # Creates a list where each entry contains a data frame storing the sequence of vertices' beliefs obtained by running DeGroot's model on the corresponding network until convergence is reached.
  number.updates <- list()                                                                                                                                                                      # Creates a list where each entry stores the number of iterations needed for beliefs' convergence of DeGroot model applied to the corresponding network.
  
  ##############################################################################################################################################################################################
  ############################################################################     LISTS OF BELIEFS DESCRIPTIVES     ###########################################################################
  ##############################################################################################################################################################################################
  
  mean.beliefs <- list()                                                                                                                                                                        # Creates a list where each entry stores the mean of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  median.beliefs <- list()                                                                                                                                                                      # Creates a list where each entry stores the median of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  mode.beliefs <- list()                                                                                                                                                                        # Creates a list where each entry stores the mode of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  standard.deviation.beliefs <- list()                                                                                                                                                          # Creates a list where each entry stores the standard deviation of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  max.beliefs <- list()                                                                                                                                                                         # Creates a list where each entry stores the maximum value of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  min.beliefs <- list()                                                                                                                                                                         # Creates a list where each entry stores the minimum value of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  range.beliefs <- list()                                                                                                                                                                       # Creates a list where each entry stores the difference between the maximum and the minimum values of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  quartile.1.beliefs <- list()                                                                                                                                                                  # Creates a list where each entry stores the first quartile of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  quartile.3.beliefs <- list()                                                                                                                                                                  # Creates a list where each entry stores the third quartile of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  range.quartile.beliefs <- list()                                                                                                                                                              # Creates a list where each entry stores the difference between the third and the first quartiles of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  skewness.beliefs <- list()                                                                                                                                                                    # Creates a list where each entry stores the skewness of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  standard.deviation.mean.beliefs <- list()                                                                                                                                                     # Creates a list where each entry stores the relative (to the mean) standard deviation of the beliefs at each round of iteration of the DeGroot model applied to the corresponding network.
  
  ##############################################################################################################################################################################################
  ###################################################################################     ERDÖS AND RENYI     ##################################################################################
  ##############################################################################################################################################################################################
  
  convergence <- list()                                                                                                                                                                         # Creates a list where each entry tells whether the vertices' beliefs have converged or not after 10000 iterations of the DeGroot model on the corresponding network.
  
  for (n in 1:networks.number){                                                                                                                                                                 # Loop for on the number of networks that we are going to create and study.
    
    cat("\r", "probability", p, "of", length(prob), "/ network", n, "of", networks.number)                                                                                                      # Counter.
    flush.console()                                                                                                                                                                             # Updates the counter on the screen.
    gc(reset=TRUE)                                                                                                                                                               	# Releases memory whenever "n" is a multiple of 10.
    
    try({                                                                                                                                                                                       # In case of error move on to the next network.
      
      network <- erdos.renyi.game(vertices.number,  p = prob[p], loops = FALSE)                                                                                                                 # Creates an Erdös-Renyi random network.
      network <- add_edges(network, rep(vertices.names, each = 2))                                                                                                                              # Adds a loop to each vertex of the network.
      
      adjacency[[n]] <- as_adjacency_matrix(network)                                                                                                                                            # Obtains the adjacency matrix of the network and assigns it to the nth entry of the "adjacency" list.
      
      ##########################################################################################################################################################################################
      ##########################################################################     NETWORK STRUCTURE MEASURES      ###########################################################################
      ##########################################################################################################################################################################################
      
      connected[[n]] <- is.connected(network)                                                                                                                                                   # Checks whether the current network is connected and stores the conclusion (TRUE or FALSE) at the nth entry of the "connected" list.
      components.number[[n]] <- components(network)$no                                                                                                                                          # Calculates the number of components on the current network and stores this number at the nth entry of the "components.number" list.
      components.size[[n]] <- components(network)$csize/vertices.number                                                                                                                         # Calculates the relative size of the components (fraction of vertices contained in them) on the current network and stores this numeric vector at the nth entry of the "components.size" list.
      components.largest[[n]] <- max(components(network)$csize/vertices.number)                                                                                                                 # Calculates the relative size of the largest components (fraction of vertices contained in them) on the current network and stores this number at the nth entry of the "components.largest" list.
      components.largest.number[[n]] <- length(max(components(network)$csize/vertices.number))                                                                                                  # Calculates the number of largest components on the current network and stores this number at the nth entry of the "components.largest.number" list.
      mean.distance[[n]] <- mean_distance(network, directed = FALSE, unconnected = TRUE)                                                                                                        # Calculates the mean distance between the vertices on the current network and stores this number at the nth entry of the "mean.distance" list.
      diameter[[n]] <- diameter(network, directed = FALSE, unconnected = TRUE, weights = NULL)                                                                                                  # Calculates the diameter of the current network and stores this number at the nth entry of the "diameter" list.
      girth[[n]] <- girth(network, circle = FALSE)                                                                                                                                              # Calculates the girth of the current network and stores this number at the nth entry of the "girth" list.
      cliques3[[n]] <- length(cliques(network, min = 3, max = NULL))                                                                                                                            # Calculates the number of cliques with at least 3 vertices on the current network and stores this number at the nth entry of the "cliques3" list.
      cliques4[[n]] <- length(cliques(network, min = 4, max = NULL))                                                                                                                            # Calculates the number of cliques with at least 4 vertices on the current network and stores this number at the nth entry of the "cliques4" list.
      cliques.largest[[n]] <- clique_num(network)/vertices.number                                                                                                                               # Calculates the relative size of the largest cliques (fraction of vertices contained in them) on the current network and stores this number at the nth entry of the "cliques.largest" list.
      cliques.largest.number[[n]] <- length(largest_cliques(network))                                                                                                                           # Calculates the number of largest cliques on the current network and stores this number at the nth entry of the "cliques.largest.number" list.
      maximal.cliques.number[[n]] <- count_max_cliques(network)                                                                                                                                 # Calculates the number of maximal cliques on the current network and stores this number at the nth entry of the "maximal.cliques.number" list.
      
      ##########################################################################################################################################################################################
      ##############################################################################     CENTRALITY MEASURES      ##############################################################################
      ##########################################################################################################################################################################################
      
      degree[[n]] <- degree(network, loops = FALSE) + 1                                                                                                                                         # Calculates each vertex's degree on the current network, where a loop counts only once, and stores this numeric vector at the nth entry of the "degree" list.
      
      #if (det(as.matrix(adjacency[[n]])) != 0){                                                                                                                                                 # Checks if the current adjacency matrix is singular or not.
        #alpha.centrality[[n]] <- alpha_centrality(network, nodes = V(network), alpha = 1, loops = FALSE, exo = 1, weights = NA, tol = 1e-07, sparse = TRUE)                                     # If the current adjacency matrix is nonsingular, calculates each vertex's alpha-centrality on the current network and stores this numeric vector at the nth entry of the "alpha.centrality" list. Singular adjacency matrices cause problems for this algorithm, the routine may fail in certain cases.
        #power.centrality[[n]] <- power_centrality(network, nodes = V(network), loops = FALSE, exponent = 1, rescale = FALSE, tol = 1e-07, sparse = TRUE)                                        # If the current adjacency matrix is nonsingular, calculates each vertex's Bonacich power centrality scores of network position on the current network and stores this numeric vector at the nth entry of the "power.centrality" list. Singular adjacency matrices cause no end of headaches for this algorithm; thus, the routine may fail in certain cases.
      #}else{                                                                                                                                                                                    # In case the current adjacency matrix is singular...
        #alpha.centrality[[n]] <- rep(NA, times = vertices.number)                                                                                                                               # If the current adjacency matrix is singular, stores a vector of NAs at the nth entry of the "alpha.centrality" list.
        #power.centrality[[n]] <- rep(NA, times = vertices.number)                                                                                                                               # If the current adjacency matrix is singular, stores a vector of NAs at the nth entry of the "power.centrality" list.
      #}
      
      authority.score[[n]] <- authority_score(network, scale = TRUE, weights = NULL, options = arpack_defaults)$vector                                                                          # Calculates each vertex's Kleinberg's authority centrality score on the current network and stores this numeric vector at the nth entry of the "authority.score" list. The authority scores of the vertices are defined as the principal eigenvector of A'A, where A is the adjacency matrix of the graph. For undirected matrices the adjacency matrix is symmetric and the authority scores are the same as hub scores.
      hub.score[[n]] <- authority_score(network, scale = TRUE, weights = NULL, options = arpack_defaults)$vector                                                                                # Calculates each vertex's Kleinberg's hub centrality score on the current network and stores this numeric vector at the nth entry of the "hub.score" list. The hub scores of the vertices are defined as the principal eigenvector of A'A, where A is the adjacency matrix of the graph. For undirected matrices the adjacency matrix is symmetric and the hub scores are the same as authority scores.
      eigen.centrality[[n]] <- eigen_centrality(network, directed = FALSE, scale = TRUE, weights = NULL, options = arpack_defaults)$vector                                                      # Calculates each vertex's eigenvector centrality score of network position on the current network and stores this numeric vector at the nth entry of the "eigen.centrality" list.
      triangle.centrality[[n]] <- count_triangles(network, vids = V(network))                                                                                                                   # Calculates how many triangles each vertex is part of on the current network and stores this numeric vector at the nth entry of the "triangle.centrality" list.
      closeness.centrality[[n]] <- closeness(network, vids = V(network), mode = c("out", "in", "all", "total"), weights = NULL, normalized = FALSE)                                             # Calculates each vertex's closeness centrality on the current network and stores this numeric vector at the nth entry of the "closeness.centrality" list.
      burt[[n]] <- constraint(network, nodes = V(network), weights = NULL)                                                                                                                      # Calculates each vertex's Burt's constraint on the current network and stores this numeric vector at the nth entry of the "burt" list.
      longest.geodesic[[n]] <- eccentricity(network, vids = V(network), mode = c("all", "out", "in", "total"))                                                                                  # Calculates each vertex's shortest path distance from the farthest other vertex on the current network and stores this numeric vector at the nth entry of the "longest.geodesic" list.
      betweenness[[n]] <- betweenness(network, v = V(network), directed = FALSE, weights = NULL, nobigint = TRUE, normalized = FALSE)                                                           # Calculates each vertex's betweenness centrality and stores this numeric vector at the nth entry of the "betweenness" list.
      degree.centrality.network[[n]] <- centr_degree(network, mode = c("all", "out", "in", "total"), loops = FALSE, normalized = TRUE)$centralization                                           # Calculates the network-level degree centrality and stores this number at the nth entry of the "degree.centrality.network" list. Because the normalized argument is set TRUE, the result is divided by the maximum theoretical network-level centralization score for a graph with the given number of vertices, using the same parameters.
      eigen.centrality.network[[n]] <- centr_eigen(network, directed = FALSE, scale = TRUE, options = arpack_defaults, normalized = TRUE)$centralization                                        # Calculates the network-level eigenvector centrality and stores this number at the nth entry of the "eigen.centrality.network" list. Because the normalized argument is set TRUE, the result is divided by the maximum theoretical network-level centralization score for a graph with the given number of vertices, using the same parameters.
      closeness.centrality.network[[n]] <- centr_clo(network, mode = c("out", "in", "all", "total"), normalized = TRUE)$centralization                                                          # If the current network is connected, calculates the network-level closeness centrality and stores this number at the nth entry of the "closeness.centrality.network" list. Because the normalized argument is set TRUE, the result is divided by the maximum theoretical network-level centralization score for a graph with the given number of vertices, using the same parameters.
      betweenness.centrality.network[[n]] <- centr_betw(network, directed = FALSE, nobigint = TRUE, normalized = TRUE)$centralization                                                           # Calculates the network-level betweenness centrality and stores this number at the nth entry of the "betweenness.centrality.network" list. Because the normalized argument is set TRUE, the result is divided by the maximum theoretical network-level centralization score for a graph with the given number of vertices, using the same parameters.
      
      ##########################################################################################################################################################################################
      ############################################################################     DEGROOT MODEL ITERATION     #############################################################################
      ##########################################################################################################################################################################################
      
      weights <- adjacency[[n]]/degree[[n]]                                                                                                                                                     # Creates a matrix of weights that tells how much weight each vertex assigns to each one of the vertices' belief. It is a row stochastic matrix, whose entries across each row sum to 1. In particular, we assume that each vertex weights their belief and those of their neighbors equally. The other vertices' beliefs are irrelevant, thus receive zero consideration (weight).
      
      priors <- runif(vertices.number)                                                                                                                                                          # Creates a uniformly random vector of vertices' priors in the range (0, 1).
      beliefs[[n]] <- cbind(priors, weights %*% priors)                                                                                                                                         # Updates vertices' priors using the matrix of weights. Stores the priors and the updated beliefs vector as a matrix at the nth entry of the "beliefs" list.
      delta <- abs(beliefs[[n]][, ncol(beliefs[[n]])] - beliefs[[n]][, ncol(beliefs[[n]])-1])                                                                                                   # Calculates the absolute change in each vertex' belief resulting from the beliefs update.
      
      if (any(delta > 1/100)){                                                                                                                                                                  # Checks if the beliefs have converged already in the first update (very unlikely).
        
        t <- 1
        while (any(delta > 1/100) & t < 1000){                                                                                                                                                  # Iterates until beliefs' have not converged.
          beliefs[[n]] <- cbind(beliefs[[n]], weights %*% beliefs[[n]][, ncol(beliefs[[n]])])                                                                                                   # Updates vertices' beliefs using the matrix of weights. Stores the history of updated beliefs as a matrix at the nth entry of the "beliefs" list.
          delta <- abs(beliefs[[n]][, ncol(beliefs[[n]])] - beliefs[[n]][, ncol(beliefs[[n]])-1])                                                                                               # Calculates the absolute change in each vertex' belief resulting from the beliefs update.
          t <- t+1
        }
        
        colnames(beliefs[[n]]) <- c("Priors", paste("Beliefs", 1:(ncol(beliefs[[n]])-1), sep="."))                                                                                              # Names the columns of "beliefs[[n]]" according to the beliefs update round.
        
      }else{                                                                                                                                                                                    # In case the beliefs have converged already in the first update (very unlikely)...
        colnames(beliefs[[n]]) <- c("Priors", "Beliefs.1")                                                                                                                                      # Names the columns of "beliefs[[n]]".
      }
      
      if (all(delta <= 1/100)){convergence[[n]] <- "Yes"}else{convergence[[n]] <- "No"}                                                                                                         # Stores at the nth entry of the "convergence" list the information of whether the vertices' beliefs have converged or not after 1000 iterations of the DeGroot model on the corresponding network.
      
      ##########################################################################################################################################################################################
      ##############################################################################     BELIEFS DESCRIPTIVES     ##############################################################################
      ##########################################################################################################################################################################################
      
      number.updates[[n]] <- t                                                                                                                                                                  # Stores at the nth entry of the "number.updates" list the number of beliefs updates performed on the corresponding network.
      mean.beliefs[[n]] <- apply(beliefs[[n]], 2, mean)                                                                                                                                         # Stores at the nth entry of the "mean.beliefs" list the mean of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      median.beliefs[[n]] <- apply(beliefs[[n]], 2, median)                                                                                                                                     # Stores at the nth entry of the "median.beliefs" list the median of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      mode.beliefs[[n]] <- apply(beliefs[[n]], 2, Mode)                                                                                                                                         # Stores at the nth entry of the "mode.beliefs" list the mode of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      standard.deviation.beliefs[[n]] <- apply(beliefs[[n]], 2, sd)                                                                                                                             # Stores at the nth entry of the "standard.deviation.beliefs" list the standard deviation of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      max.beliefs[[n]] <- apply(beliefs[[n]], 2, max)                                                                                                                                           # Stores at the nth entry of the "max.beliefs" list the maximum value of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      min.beliefs[[n]] <- apply(beliefs[[n]], 2, min)                                                                                                                                           # Stores at the nth entry of the "min.beliefs" list the minimum value of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      range.beliefs[[n]] <- max.beliefs[[n]] - min.beliefs[[n]]                                                                                                                                 # Stores at the nth entry of the "range.beliefs" list the difference between the maximum and the minimum values of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      quartile.1.beliefs[[n]] <- apply(beliefs[[n]], 2, function(x) quantile(x, probs = 0.25))                                                                                                  # Stores at the nth entry of the "quartile.1.beliefs" list the first quartile of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      quartile.3.beliefs[[n]] <- apply(beliefs[[n]], 2, function(x) quantile(x, probs = 0.75))                                                                                                  # Stores at the nth entry of the "quartile.3.beliefs" list the third quartile of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      range.quartile.beliefs[[n]] <- quartile.3.beliefs[[n]] - quartile.1.beliefs[[n]]                                                                                                          # Stores at the nth entry of the "range.quartile.beliefs" list the difference between the third and the first quartiles of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      skewness.beliefs[[n]] <- apply(beliefs[[n]], 2, skewness)                                                                                                                                 # Stores at the nth entry of the "skewness.beliefs" list the skewness of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
      
      division <- function(x, y){x/y}                                                                                                                                                           # Creates a function to divide one number by another.
      
      standard.deviation.mean.beliefs[[n]] <- mapply(division, x = standard.deviation.beliefs[[n]], y = mean.beliefs[[n]])                                                                      # Stores at the nth entry of the "standard.deviation.mean.beliefs" list the relative (to the mean) standard deviation of the beliefs at each round of iteration of DeGroot model applied to the corresponding network.
             
    }, silent = FALSE)
    
  }
  
  ##############################################################################################################################################################################################
  #########################################################################     PUTTING THE DESIRED DATA TOGETHER     ##########################################################################
  ##############################################################################################################################################################################################
  
  start.end <- function(x){data.frame(t(c(x[1], x[length(x)])))}                                                                                                                                # Function to select only the first and the last element of a vector "x" and store them as a data frame.
  
  mean.beliefs.df <- lapply(mean.beliefs, start.end)                                                                                                                                            # Applies the function "start.end" function to the elements in the "mean.beliefs" list.
  median.beliefs.df <- lapply(median.beliefs, start.end)                                                                                                                                        # Applies the function "start.end" function to the elements in the "median.beliefs" list.
  standard.deviation.beliefs.df <- lapply(standard.deviation.beliefs, start.end)                                                                                                                # Applies the function "start.end" function to the elements in the "standard.deviation.beliefs" list.
  max.beliefs.df <- lapply(max.beliefs, start.end)                                                                                                                                              # Applies the function "start.end" function to the elements in the "max.beliefs" list.
  min.beliefs.df <- lapply(min.beliefs, start.end)                                                                                                                                              # Applies the function "start.end" function to the elements in the "min.beliefs" list.
  range.beliefs.df <- lapply(range.beliefs, start.end)                                                                                                                                          # Applies the function "start.end" function to the elements in the "range.beliefs" list.
  quartile.1.beliefs.df <- lapply(quartile.1.beliefs, start.end)                                                                                                                                # Applies the function "start.end" function to the elements in the "quartile.1.beliefs" list.
  quartile.3.beliefs.df <- lapply(quartile.3.beliefs, start.end)                                                                                                                                # Applies the function "start.end" function to the elements in the "quartile.3.beliefs" list.
  range.quartile.beliefs.df <- lapply(range.quartile.beliefs, start.end)                                                                                                                        # Applies the function "start.end" function to the elements in the "range.quartile.beliefs" list.
  skewness.beliefs.df <- lapply(skewness.beliefs, start.end)                                                                                                                                    # Applies the function "start.end" function to the elements in the "skewness.beliefs" list.
  standard.deviation.mean.beliefs.df <- lapply(standard.deviation.mean.beliefs, start.end)                                                                                                      # Applies the function "start.end" function to the elements in the "standard.deviation.mean.beliefs" list.
  
  for (q in 1:networks.number){
    names(mean.beliefs.df[[q]]) <- c("mean.beliefs.start", "mean.beliefs.end")                                                                                                                  # Renames the columns of the data frames in the "mean.beliefs.df" list.
    names(median.beliefs.df[[q]]) <- c("median.beliefs.start", "median.beliefs.end")                                                                                                            # Renames the columns of the data frames in the "median.beliefs.df" list.
    names(standard.deviation.beliefs.df[[q]]) <- c("standard.deviation.beliefs.start", "standard.deviation.beliefs.end")                                                                        # Renames the columns of the data frames in the "standard.deviation.beliefs.df" list.
    names(max.beliefs.df[[q]]) <- c("max.beliefs.start", "max.beliefs.end")                                                                                                                     # Renames the columns of the data frames in the "max.beliefs.df" list.
    names(min.beliefs.df[[q]]) <- c("min.beliefs.start", "min.beliefs.end")                                                                                                                     # Renames the columns of the data frames in the "min.beliefs.df" list.
    names(range.beliefs.df[[q]]) <- c("range.beliefs.start", "range.beliefs.end")                                                                                                               # Renames the columns of the data frames in the "range.beliefs.df" list.
    names(quartile.1.beliefs.df[[q]]) <- c("quartile.1.beliefs.start", "quartile.1.beliefs.end")                                                                                                # Renames the columns of the data frames in the "quartile.1.beliefs.df" list.
    names(quartile.3.beliefs.df[[q]]) <- c("quartile.3.beliefs.start", "quartile.3.beliefs.end")                                                                                                # Renames the columns of the data frames in the "quartile.3.beliefs.df" list.
    names(range.quartile.beliefs.df[[q]]) <- c("range.quartile.beliefs.start", "range.quartile.beliefs.end")                                                                                    # Renames the columns of the data frames in the "range.quartile.beliefs.df" list.
    names(skewness.beliefs.df[[q]]) <- c("skewness.beliefs.start", "skewness.beliefs.end")                                                                                                      # Renames the columns of the data frames in the "skewness.beliefs.df" list.
    names(standard.deviation.mean.beliefs.df[[q]]) <- c("standard.deviation.mean.beliefs.start", "standard.deviation.mean.beliefs.end")                                                         # Renames the columns of the data frames in the "standard.deviation.mean.beliefs.df" list.
  }
  
  mean.beliefs.df <- do.call(rbind, mean.beliefs.df)                                                                                                                                            # Stacks the data frames in the "mean.beliefs.df" list into one single data frame. 
  median.beliefs.df <- do.call(rbind, median.beliefs.df)                                                                                                                                        # Stacks the data frames in the "median.beliefs.df" list into one single data frame. 
  standard.deviation.beliefs.df <- do.call(rbind, standard.deviation.beliefs.df)                                                                                                                # Stacks the data frames in the "standard.deviation.beliefs.df" list into one single data frame. 
  max.beliefs.df <- do.call(rbind, max.beliefs.df)                                                                                                                                              # Stacks the data frames in the "max.beliefs.df" list into one single data frame. 
  min.beliefs.df <- do.call(rbind, min.beliefs.df)                                                                                                                                              # Stacks the data frames in the "min.beliefs.df" list into one single data frame. 
  range.beliefs.df <- do.call(rbind, range.beliefs.df)                                                                                                                                          # Stacks the data frames in the "range.beliefs.df" list into one single data frame. 
  quartile.1.beliefs.df <- do.call(rbind, quartile.1.beliefs.df)                                                                                                                                # Stacks the data frames in the "quartile.1.beliefs.df" list into one single data frame. 
  quartile.3.beliefs.df <- do.call(rbind, quartile.3.beliefs.df)                                                                                                                                # Stacks the data frames in the "quartile.3.beliefs.df" list into one single data frame. 
  range.quartile.beliefs.df <- do.call(rbind, range.quartile.beliefs.df)                                                                                                                        # Stacks the data frames in the "range.quartile.beliefs.df" list into one single data frame. 
  skewness.beliefs.df <- do.call(rbind, skewness.beliefs.df)                                                                                                                                    # Stacks the data frames in the "skewness.beliefs.df" list into one single data frame. 
  standard.deviation.mean.beliefs.df <- do.call(rbind, standard.deviation.mean.beliefs.df)                                                                                                      # Stacks the data frames in the "standard.deviation.mean.beliefs.df" list into one single data frame. 
  
  mean.beliefs.df$"mean.beliefs.delta" <- mean.beliefs.df$"mean.beliefs.end" - mean.beliefs.df$"mean.beliefs.start"                                                                             # Calculates the change in "mean.beliefs.df".
  median.beliefs.df$"median.beliefs.delta" <- median.beliefs.df$"median.beliefs.end" - median.beliefs.df$"median.beliefs.start"                                                                 # Calculates the change in "median.beliefs.df".
  standard.deviation.beliefs.df$"standard.deviation.beliefs.delta" <- standard.deviation.beliefs.df$"standard.deviation.beliefs.end" -
    standard.deviation.beliefs.df$"standard.deviation.beliefs.start"                                                                                                                            # Calculates the change in "standard.deviation.beliefs.df".
  max.beliefs.df$"max.beliefs.delta" <- max.beliefs.df$"max.beliefs.end" - max.beliefs.df$"max.beliefs.start"                                                                                   # Calculates the change in "max.beliefs.df".
  min.beliefs.df$"min.beliefs.delta" <- min.beliefs.df$"min.beliefs.end" - min.beliefs.df$"min.beliefs.start"                                                                                   # Calculates the change in "min.beliefs.df".
  range.beliefs.df$"range.beliefs.delta" <- range.beliefs.df$"range.beliefs.end" - range.beliefs.df$"range.beliefs.start"                                                                       # Calculates the change in "range.beliefs.df".
  quartile.1.beliefs.df$"quartile.1.beliefs.delta" <- quartile.1.beliefs.df$"quartile.1.beliefs.end" - quartile.1.beliefs.df$"quartile.1.beliefs.start"                                         # Calculates the change in "quartile.1.beliefs.df".
  quartile.3.beliefs.df$"quartile.3.beliefs.delta" <- quartile.3.beliefs.df$"quartile.3.beliefs.end" - quartile.3.beliefs.df$"quartile.3.beliefs.start"                                         # Calculates the change in "quartile.3.beliefs.df".
  range.quartile.beliefs.df$"range.quartile.beliefs.delta" <- range.quartile.beliefs.df$"range.quartile.beliefs.end" - range.quartile.beliefs.df$"range.quartile.beliefs.start"                 # Calculates the change in "range.quartile.beliefs.df".
  skewness.beliefs.df$"skewness.beliefs.delta" <- skewness.beliefs.df$"skewness.beliefs.end" - skewness.beliefs.df$"skewness.beliefs.start"                                                     # Calculates the change in "skewness.beliefs.df".
  standard.deviation.mean.beliefs.df$"standard.deviation.mean.beliefs.delta" <- standard.deviation.mean.beliefs.df$"standard.deviation.mean.beliefs.end" -
    standard.deviation.mean.beliefs.df$"standard.deviation.mean.beliefs.start"                                                                                                                  # Calculates the change in "standard.deviation.mean.beliefs.df".
  
  data <- data.frame(                                                                                                                                                                           # Joins all the desired data into one single data frame.
    probability,
    mean.beliefs.df,
    median.beliefs.df,
    standard.deviation.beliefs.df,
    standard.deviation.mean.beliefs.df,
    max.beliefs.df,
    min.beliefs.df,
    range.beliefs.df,
    quartile.1.beliefs.df,
    quartile.3.beliefs.df,
    range.quartile.beliefs.df,
    skewness.beliefs.df,
    "connected" = unlist(connected),
    "components.number" = unlist(components.number),
    "components.largest" = unlist(components.largest),
    "components.largest.number" = unlist(components.largest.number),
    "mean.distance" = unlist(mean.distance),
    "diameter" = unlist(diameter),
    "girth" = unlist(girth),
    "cliques3" = unlist(cliques3),
    "cliques4" = unlist(cliques4),
    "cliques.largest" = unlist(cliques.largest),
    "cliques.largest.number" = unlist(cliques.largest.number),
    "maximal.cliques.number" = unlist(maximal.cliques.number),
    "degree.centrality.network" = unlist(degree.centrality.network),
    "eigen.centrality.network" = unlist(eigen.centrality.network),
    "closeness.centrality.network" = unlist(closeness.centrality.network),
    "betweenness.centrality.network" = unlist(betweenness.centrality.network),
    "number.updates" = unlist(number.updates),
    "convergence" = unlist(convergence)
  )
  
  ##############################################################################################################################################################################################
  ############################################################################     SAVING AND RELEASING MEMORY     #############################################################################
  ##############################################################################################################################################################################################
  
  setwd("E:/UFABC/Graduação/Orientação de PDPD/Editais 7 e 8 de 2023/Samuel Oliveira Pivante/Dados/Dados Completos")                                                                            # Sets the working directory where the full set of data will be saved.
  save.image(file = paste("DeGroot - Erdos & Reny - ", "Probability ", prob[p], ".RData", sep=""))                                                                                              # Saves everything in the workspace and names the resulting file conveniently.
  
  setwd("E:/UFABC/Graduação/Orientação de PDPD/Editais 7 e 8 de 2023/Samuel Oliveira Pivante/Dados/Dados Utilizados")                                                                          	# Sets the working directory where "data" will be saved.
  save(data, file = paste("Data - DeGroot - Erdos & Reny - ", "Probability ", prob[p], ".RData", sep=""))                                                                                       # Saves "data" in the workspace and names the resulting file conveniently.
  
  gc(reset=TRUE)                                                                                                                                                                                # Releases memory.
  
}
